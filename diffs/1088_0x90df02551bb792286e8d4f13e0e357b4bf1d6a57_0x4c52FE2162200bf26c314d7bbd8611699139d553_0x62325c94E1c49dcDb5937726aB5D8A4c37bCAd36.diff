diff --git a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/BorrowLogic.sol b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/BorrowLogic.sol
index 1b1a18b..e71aecf 100644
--- a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/BorrowLogic.sol
+++ b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/BorrowLogic.sol
@@ -229,6 +229,7 @@ library BorrowLogic {
             paybackAmount
         );
 
+        // in case of aToken repayment the msg.sender must always repay on behalf of itself
         if (params.useATokens) {
             IAToken(reserveCache.aTokenAddress).burn(
                 msg.sender,
@@ -236,11 +237,13 @@ library BorrowLogic {
                 paybackAmount,
                 reserveCache.nextLiquidityIndex
             );
-            // in case of aToken repayment the msg.sender must always repay on behalf of itself
+            bool isCollateral = userConfig.isUsingAsCollateral(reserve.id);
             if (
+                isCollateral &&
                 IAToken(reserveCache.aTokenAddress).scaledBalanceOf(
                     msg.sender
-                ) == 0
+                ) ==
+                0
             ) {
                 userConfig.setUsingAsCollateral(reserve.id, false);
                 emit ReserveUsedAsCollateralDisabled(params.asset, msg.sender);
diff --git a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/DataTypes.sol b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/DataTypes.sol
index a4bfaef..8e5b1a9 100644
--- a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/DataTypes.sol
+++ b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/DataTypes.sol
@@ -217,6 +217,11 @@ library DataTypes {
         uint8 userEModeCategory;
     }
 
+    struct ExecuteEliminateDeficitParams {
+        address asset;
+        uint256 amount;
+    }
+
     struct ExecuteSetUserEModeParams {
         uint256 reservesCount;
         address oracle;
diff --git a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/EModeConfiguration.sol b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/EModeConfiguration.sol
index 2b0489a..5f687dc 100644
--- a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/EModeConfiguration.sol
+++ b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/EModeConfiguration.sol
@@ -2,7 +2,6 @@
 pragma solidity ^0.8.0;
 
 import {Errors} from "../helpers/Errors.sol";
-import {DataTypes} from "../types/DataTypes.sol";
 import {ReserveConfiguration} from "./ReserveConfiguration.sol";
 
 /**
diff --git a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/EModeLogic.sol b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/EModeLogic.sol
index 4458909..fd2e7ea 100644
--- a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/EModeLogic.sol
+++ b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/EModeLogic.sol
@@ -3,7 +3,6 @@ pragma solidity ^0.8.10;
 
 import {GPv2SafeERC20} from "../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol";
 import {IERC20} from "../../../dependencies/openzeppelin/contracts/IERC20.sol";
-import {IPriceOracleGetter} from "../../../interfaces/IPriceOracleGetter.sol";
 import {UserConfiguration} from "../configuration/UserConfiguration.sol";
 import {WadRayMath} from "../math/WadRayMath.sol";
 import {PercentageMath} from "../math/PercentageMath.sol";
diff --git a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/Errors.sol b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/Errors.sol
index 0b4d7df..eb8c305 100644
--- a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/Errors.sol
+++ b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/Errors.sol
@@ -101,7 +101,8 @@ library Errors {
     string public constant INVALID_GRACE_PERIOD = "98"; // Grace period above a valid range
     string public constant INVALID_FREEZE_STATE = "99"; // Reserve is already in the passed freeze state
     string public constant NOT_BORROWABLE_IN_EMODE = "100"; // Asset not borrowable in eMode
-    string public constant USER_NOT_IN_BAD_DEBT = "101"; // The user is not in bad debt
-    string public constant CALLER_NOT_UMBRELLA = "102"; // The caller of the function is not the umbrella contract
-    string public constant RESERVE_NOT_IN_DEFICIT = "103"; //  The reserve is not in deficit
+    string public constant CALLER_NOT_UMBRELLA = "101"; // The caller of the function is not the umbrella contract
+    string public constant RESERVE_NOT_IN_DEFICIT = "102"; // The reserve is not in deficit
+    string public constant MUST_NOT_LEAVE_DUST = "103"; // Below a certain threshold liquidators need to take the full position
+    string public constant USER_CANNOT_HAVE_DEBT = "104"; // Thrown when a user tries to interact with a method that requires a position without debt
 }
diff --git a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/GenericLogic.sol b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/GenericLogic.sol
index a3efd9a..16d348e 100644
--- a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/GenericLogic.sol
+++ b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/GenericLogic.sol
@@ -159,12 +159,20 @@ library GenericLogic {
             }
 
             if (params.userConfig.isBorrowing(vars.i)) {
-                vars.totalDebtInBaseCurrency += _getUserDebtInBaseCurrency(
-                    params.user,
-                    currentReserve,
-                    vars.assetPrice,
-                    vars.assetUnit
-                );
+                if (currentReserve.configuration.getIsVirtualAccActive()) {
+                    vars.totalDebtInBaseCurrency += _getUserDebtInBaseCurrency(
+                        params.user,
+                        currentReserve,
+                        vars.assetPrice,
+                        vars.assetUnit
+                    );
+                } else {
+                    // custom case for GHO, which applies the GHO discount on balanceOf
+                    vars.totalDebtInBaseCurrency +=
+                        (IERC20(currentReserve.variableDebtTokenAddress)
+                            .balanceOf(params.user) * vars.assetPrice) /
+                        vars.assetUnit;
+                }
             }
 
             unchecked {
diff --git a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/IPool.sol b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/IPool.sol
index 4842e5d..f0ed8d2 100644
--- a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/IPool.sol
+++ b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/IPool.sol
@@ -207,13 +207,13 @@ interface IPool {
     /**
      * @dev Emitted when the deficit of a reserve is covered.
      * @param reserve The address of the underlying asset of the reserve
+     * @param caller The caller that triggered the DeficitCovered event
      * @param amountCovered The amount of deficit covered
-     * @param currentDeficit The current deficit of the reserve.
      */
-    event BadDebtCovered(
+    event DeficitCovered(
         address indexed reserve,
-        uint256 amountCovered,
-        uint256 currentDeficit
+        address caller,
+        uint256 amountCovered
     );
 
     /**
@@ -224,15 +224,15 @@ interface IPool {
     event MintedToTreasury(address indexed reserve, uint256 amountMinted);
 
     /**
-     *
+     * @dev Emitted when deficit is realized on a liquidation.
      * @param user The user address where the bad debt will be burned
      * @param debtAsset The address of the underlying borrowed asset to be burned
-     * @param amount The amount to burn
+     * @param amountCreated The amount of deficit created
      */
-    event BadDebtBurned(
+    event DeficitCreated(
         address indexed user,
         address indexed debtAsset,
-        uint256 amount
+        uint256 amountCreated
     );
 
     /**
@@ -624,15 +624,6 @@ interface IPool {
         address asset
     ) external view returns (DataTypes.ReserveDataLegacy memory);
 
-    /**
-     * @notice Returns the state and configuration of the reserve, including extra data included with Aave v3.1
-     * @param asset The address of the underlying asset of the reserve
-     * @return The state and configuration data of the reserve with virtual accounting
-     */
-    function getReserveDataExtended(
-        address asset
-    ) external view returns (DataTypes.ReserveData memory);
-
     /**
      * @notice Returns the virtual underlying balance of the reserve
      * @param asset The address of the underlying asset of the reserve
@@ -826,7 +817,9 @@ interface IPool {
      * @return Timestamp when the liquidation grace period will end
      *
      */
-    function getLiquidationGracePeriod(address asset) external returns (uint40);
+    function getLiquidationGracePeriod(
+        address asset
+    ) external view returns (uint40);
 
     /**
      * @notice Returns the total fee on flash loans
@@ -886,29 +879,38 @@ interface IPool {
     ) external;
 
     /**
-     * @notice Validate and burn all bad debt of users.
-     * @dev A user is considered to be in bad debt if, after liquidation, they have all collateral liquidated
-     * while leaving some debt unpaid. This condition indicates that the user's debt is unlikely to be repaid,
-     * necessitating a debt write-off to prevent further interest accrual.
-     * @param users The array of addresses in bad debt.
-     */
-    function burnBadDebt(address[] calldata users) external;
-
-    /**
-     * @notice It Covers the deficit of a specified reserve by burning the equivalent aToken `amount`.
+     * @notice It covers the deficit of a specified reserve by burning:
+     * - the equivalent aToken `amount` for assets with virtual accounting enabled
+     * - the equivalent `amount` of underlying for assets with virtual accounting disabled (e.g. GHO)
      * @dev The deficit of a reserve can occur due to situations where borrowed assets are not repaid, leading to bad debt.
-     * @param asset The address of the underlying asset to cover the dificit.
-     * @param amount The amount to be covered.
+     * @param asset The address of the underlying asset to cover the deficit.
+     * @param amount The amount to be covered, in aToken or underlying on non-virtual accounted assets
      */
     function eliminateReserveDeficit(address asset, uint256 amount) external;
 
     /**
      * @notice Returns the current deficit of a reserve.
      * @param asset The address of the underlying asset of the reserve
-     * @return The the current deficit
+     * @return The current deficit of the reserve
      */
     function getReserveDeficit(address asset) external view returns (uint256);
 
+    /**
+     * @notice Returns the aToken address of a reserve.
+     * @param asset The address of the underlying asset of the reserve
+     * @return The address of the aToken
+     */
+    function getReserveAToken(address asset) external view returns (address);
+
+    /**
+     * @notice Returns the variableDebtToken address of a reserve.
+     * @param asset The address of the underlying asset of the reserve
+     * @return The address of the variableDebtToken
+     */
+    function getReserveVariableDebtToken(
+        address asset
+    ) external view returns (address);
+
     /**
      * @notice Gets the address of the external FlashLoanLogic
      */
diff --git a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/IsolationModeLogic.sol b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/IsolationModeLogic.sol
index e5a02ec..e545abc 100644
--- a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/IsolationModeLogic.sol
+++ b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/IsolationModeLogic.sol
@@ -23,7 +23,7 @@ library IsolationModeLogic {
     );
 
     /**
-     * @notice updated the isolated debt whenever a position collateralized by an isolated asset is repaid or liquidated
+     * @notice updated the isolated debt whenever a position collateralized by an isolated asset is repaid
      * @param reservesData The state of all the reserves
      * @param reservesList The addresses of all the active reserves
      * @param userConfig The user configuration mapping
@@ -44,36 +44,56 @@ library IsolationModeLogic {
         ) = userConfig.getIsolationModeState(reservesData, reservesList);
 
         if (isolationModeActive) {
-            uint128 isolationModeTotalDebt = reservesData[
+            updateIsolatedDebt(
+                reservesData,
+                reserveCache,
+                repayAmount,
                 isolationModeCollateralAddress
-            ].isolationModeTotalDebt;
+            );
+        }
+    }
+
+    /**
+     * @notice updated the isolated debt whenever a position collateralized by an isolated asset is liquidated
+     * @param reservesData The state of all the reserves
+     * @param reserveCache The cached data of the reserve
+     * @param repayAmount The amount being repaid
+     * @param isolationModeCollateralAddress The address of the isolated collateral
+     */
+    function updateIsolatedDebt(
+        mapping(address => DataTypes.ReserveData) storage reservesData,
+        DataTypes.ReserveCache memory reserveCache,
+        uint256 repayAmount,
+        address isolationModeCollateralAddress
+    ) internal {
+        uint128 isolationModeTotalDebt = reservesData[
+            isolationModeCollateralAddress
+        ].isolationModeTotalDebt;
 
-            uint128 isolatedDebtRepaid = (repayAmount /
-                10 **
-                    (reserveCache.reserveConfiguration.getDecimals() -
-                        ReserveConfiguration.DEBT_CEILING_DECIMALS))
-                .toUint128();
+        uint128 isolatedDebtRepaid = (repayAmount /
+            10 **
+                (reserveCache.reserveConfiguration.getDecimals() -
+                    ReserveConfiguration.DEBT_CEILING_DECIMALS)).toUint128();
 
-            // since the debt ceiling does not take into account the interest accrued, it might happen that amount
-            // repaid > debt in isolation mode
-            if (isolationModeTotalDebt <= isolatedDebtRepaid) {
-                reservesData[isolationModeCollateralAddress]
-                    .isolationModeTotalDebt = 0;
-                emit IsolationModeTotalDebtUpdated(
-                    isolationModeCollateralAddress,
-                    0
-                );
-            } else {
-                uint256 nextIsolationModeTotalDebt = reservesData[
-                    isolationModeCollateralAddress
-                ].isolationModeTotalDebt =
-                    isolationModeTotalDebt -
-                    isolatedDebtRepaid;
-                emit IsolationModeTotalDebtUpdated(
-                    isolationModeCollateralAddress,
-                    nextIsolationModeTotalDebt
-                );
-            }
+        // since the debt ceiling does not take into account the interest accrued, it might happen that amount
+        // repaid > debt in isolation mode
+        if (isolationModeTotalDebt <= isolatedDebtRepaid) {
+            reservesData[isolationModeCollateralAddress]
+                .isolationModeTotalDebt = 0;
+            emit IsolationModeTotalDebtUpdated(
+                isolationModeCollateralAddress,
+                0
+            );
+        } else {
+            uint256 nextIsolationModeTotalDebt = reservesData[
+                isolationModeCollateralAddress
+            ].isolationModeTotalDebt =
+                isolationModeTotalDebt -
+                isolatedDebtRepaid;
+            emit IsolationModeTotalDebtUpdated(
+                isolationModeCollateralAddress,
+                nextIsolationModeTotalDebt
+            );
         }
     }
 }
diff --git a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/ReserveConfiguration.sol b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/ReserveConfiguration.sol
index 322bf6d..a829da8 100644
--- a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/ReserveConfiguration.sol
+++ b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/ReserveConfiguration.sol
@@ -19,6 +19,7 @@ library ReserveConfiguration {
     uint256 internal constant ACTIVE_MASK = 0x0000000000000000000000000000000000000000000000000100000000000000; // prettier-ignore
     uint256 internal constant FROZEN_MASK = 0x0000000000000000000000000000000000000000000000000200000000000000; // prettier-ignore
     uint256 internal constant BORROWING_MASK = 0x0000000000000000000000000000000000000000000000000400000000000000; // prettier-ignore
+    // @notice there is an unoccupied hole of 1 bit at position 59 from pre 3.2 stableBorrowRateEnabled
     uint256 internal constant PAUSED_MASK = 0x0000000000000000000000000000000000000000000000001000000000000000; // prettier-ignore
     uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =
         0x0000000000000000000000000000000000000000000000002000000000000000; // prettier-ignore
@@ -568,7 +569,10 @@ library ReserveConfiguration {
     /**
      * @notice Gets the virtual account active/not state of the reserve
      * @dev The state should be true for all normal assets and should be false
-     *  only in special cases (ex. GHO) where an asset is minted instead of supplied.
+     * Virtual accounting being disabled means that the asset:
+     * - is GHO
+     * - can never be supplied
+     * - the interest rate strategy is not influenced by the virtual balance
      * @param self The reserve configuration
      * @return The active state
      */
diff --git a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/ReserveLogic.sol b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/ReserveLogic.sol
index 45b9e95..5feeea6 100644
--- a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/ReserveLogic.sol
+++ b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/ReserveLogic.sol
@@ -12,9 +12,6 @@ import {PercentageMath} from "../math/PercentageMath.sol";
 import {Errors} from "../helpers/Errors.sol";
 import {DataTypes} from "../types/DataTypes.sol";
 import {SafeCast} from "../../../dependencies/openzeppelin/contracts/SafeCast.sol";
-import {IAToken} from "../../../interfaces/IAToken.sol";
-import {UserConfiguration} from "../configuration/UserConfiguration.sol";
-import {ValidationLogic} from "./ValidationLogic.sol";
 
 /**
  * @title ReserveLogic library
@@ -28,7 +25,6 @@ library ReserveLogic {
     using GPv2SafeERC20 for IERC20;
     using ReserveLogic for DataTypes.ReserveData;
     using ReserveConfiguration for DataTypes.ReserveConfigurationMap;
-    using UserConfiguration for DataTypes.UserConfigurationMap;
 
     // See `IPool` for descriptions
     event ReserveDataUpdated(
@@ -40,16 +36,6 @@ library ReserveLogic {
         uint256 variableBorrowIndex
     );
 
-    event ReserveUsedAsCollateralDisabled(
-        address indexed reserve,
-        address indexed user
-    );
-    event BadDebtCovered(
-        address indexed reserve,
-        uint256 amountDecreased,
-        uint256 currentDeficit
-    );
-
     /**
      * @notice Returns the ongoing normalized income for the reserve.
      * @dev A value of 1e27 means there is no income. As time passes, the income is accrued
@@ -115,7 +101,9 @@ library ReserveLogic {
     ) internal {
         // If time didn't pass since last stored timestamp, skip state update
         //solium-disable-next-line
-        if (reserve.lastUpdateTimestamp == uint40(block.timestamp)) {
+        if (
+            reserveCache.reserveLastUpdateTimestamp == uint40(block.timestamp)
+        ) {
             return;
         }
 
@@ -124,6 +112,7 @@ library ReserveLogic {
 
         //solium-disable-next-line
         reserve.lastUpdateTimestamp = uint40(block.timestamp);
+        reserveCache.reserveLastUpdateTimestamp = uint40(block.timestamp);
     }
 
     /**
@@ -197,14 +186,14 @@ library ReserveLogic {
         ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)
                 .calculateInterestRates(
                     DataTypes.CalculateInterestRatesParams({
-                        unbacked: reserve.unbacked,
+                        unbacked: reserve.unbacked + reserve.deficit,
                         liquidityAdded: liquidityAdded,
                         liquidityTaken: liquidityTaken,
                         totalDebt: totalVariableDebt,
                         reserveFactor: reserveCache.reserveFactor,
                         reserve: reserveAddress,
-                        usingVirtualBalance: reserve
-                            .configuration
+                        usingVirtualBalance: reserveCache
+                            .reserveConfiguration
                             .getIsVirtualAccActive(),
                         virtualUnderlyingBalance: reserve
                             .virtualUnderlyingBalance
@@ -215,7 +204,7 @@ library ReserveLogic {
         reserve.currentVariableBorrowRate = nextVariableRate.toUint128();
 
         // Only affect virtual balance if the reserve uses it
-        if (reserve.configuration.getIsVirtualAccActive()) {
+        if (reserveCache.reserveConfiguration.getIsVirtualAccActive()) {
             if (liquidityAdded > 0) {
                 reserve.virtualUnderlyingBalance += liquidityAdded.toUint128();
             }
@@ -353,74 +342,4 @@ library ReserveLogic {
 
         return reserveCache;
     }
-
-    /**
-     * @notice Reduces a portion or all of the deficit of a specified reserve by burning the equivalent aToken `amount`.
-     * @dev Emits the `BadDebtCovered() event`.
-     * @dev If the coverage admin covers its entire balance, `ReserveUsedAsCollateralDisabled()` is emitted.
-     * @param reservesData The state of all the reserves
-     * @param reservesList The addresses of all the active reserves
-     * @param eModeCategories The configuration of all the efficiency mode categories
-     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets
-     * @param params The additional parameters needed to execute the eliminateDeficit function
-     */
-    function eliminateDeficit(
-        mapping(address => DataTypes.ReserveData) storage reservesData,
-        mapping(uint256 => address) storage reservesList,
-        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
-        DataTypes.UserConfigurationMap storage userConfig,
-        DataTypes.ExecuteWithdrawParams memory params
-    ) external {
-        require(params.amount != 0, Errors.INVALID_AMOUNT);
-
-        DataTypes.ReserveData storage reserve = reservesData[params.asset];
-        uint256 currentDeficit = reserve.deficit;
-
-        require(currentDeficit != 0, Errors.RESERVE_NOT_IN_DEFICIT);
-
-        DataTypes.ReserveCache memory reserveCache = reserve.cache();
-        reserve.updateState(reserveCache);
-
-        uint256 userBalance = IAToken(reserveCache.aTokenAddress)
-            .scaledBalanceOf(msg.sender)
-            .rayMul(reserveCache.nextLiquidityIndex);
-
-        uint256 deficitToDecrease = params.amount;
-
-        if (params.amount > currentDeficit) {
-            deficitToDecrease = currentDeficit;
-        }
-
-        bool isCollateral = userConfig.isUsingAsCollateral(reserve.id);
-
-        if (isCollateral && deficitToDecrease == userBalance) {
-            userConfig.setUsingAsCollateral(reserve.id, false);
-            emit ReserveUsedAsCollateralDisabled(params.asset, msg.sender);
-        }
-
-        IAToken(reserveCache.aTokenAddress).burn(
-            msg.sender,
-            reserveCache.aTokenAddress,
-            deficitToDecrease,
-            reserveCache.nextLiquidityIndex
-        );
-
-        if (isCollateral && userConfig.isBorrowingAny()) {
-            ValidationLogic.validateHFAndLtv(
-                reservesData,
-                reservesList,
-                eModeCategories,
-                userConfig,
-                params.asset,
-                msg.sender,
-                params.reservesCount,
-                params.oracle,
-                params.userEModeCategory
-            );
-        }
-
-        reserve.deficit -= deficitToDecrease.toUint128();
-
-        emit BadDebtCovered(params.asset, deficitToDecrease, reserve.deficit);
-    }
 }
diff --git a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/ValidationLogic.sol b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/ValidationLogic.sol
index d13dd83..c50d1f5 100644
--- a/tmp/1088_0x4c52FE2162200bf26c314d7bbd8611699139d553_flat/ValidationLogic.sol
+++ b/tmp/1088_0x62325c94E1c49dcDb5937726aB5D8A4c37bCAd36_flat/ValidationLogic.sol
@@ -4,8 +4,6 @@ pragma solidity ^0.8.10;
 import {IERC20} from "../../../dependencies/openzeppelin/contracts/IERC20.sol";
 import {Address} from "../../../dependencies/openzeppelin/contracts/Address.sol";
 import {GPv2SafeERC20} from "../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol";
-import {IReserveInterestRateStrategy} from "../../../interfaces/IReserveInterestRateStrategy.sol";
-import {IScaledBalanceToken} from "../../../interfaces/IScaledBalanceToken.sol";
 import {IPriceOracleGetter} from "../../../interfaces/IPriceOracleGetter.sol";
 import {IAToken} from "../../../interfaces/IAToken.sol";
 import {IPriceOracleSentinel} from "../../../interfaces/IPriceOracleSentinel.sol";
@@ -24,7 +22,7 @@ import {SafeCast} from "../../../dependencies/openzeppelin/contracts/SafeCast.so
 import {IncentivizedERC20} from "../../tokenization/base/IncentivizedERC20.sol";
 
 /**
- * @title ReserveLogic library
+ * @title ValidationLogic library
  * @author Aave
  * @notice Implements functions to validate the different actions of the protocol
  */
@@ -733,40 +731,4 @@ library ValidationLogic {
                 reserveConfig
             );
     }
-
-    /**
-     * @notice Validates that the user is in a bad debt situation.
-     * @dev This function ensures the presence of bad debt, defined as zero collateral value
-     * with non-zero debt value or active borrowing. Reverts if the user is not in this state.
-     * @param reservesData The state of all the reserves
-     * @param reservesList The addresses of all the active reserves
-     * @param eModeCategories The configuration of all the efficiency mode categories
-     * @param params Additional parameters needed for the calculation
-     */
-    function validateUserBadDebt(
-        mapping(address => DataTypes.ReserveData) storage reservesData,
-        mapping(uint256 => address) storage reservesList,
-        mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,
-        DataTypes.CalculateUserAccountDataParams memory params
-    ) internal view {
-        (
-            uint256 totalCollateralInBaseCurrency,
-            uint256 totalDebtInBaseCurrency,
-            ,
-            ,
-            ,
-
-        ) = GenericLogic.calculateUserAccountData(
-                reservesData,
-                reservesList,
-                eModeCategories,
-                params
-            );
-        require(
-            totalCollateralInBaseCurrency == 0 &&
-                (totalDebtInBaseCurrency != 0 ||
-                    params.userConfig.isBorrowingAny()),
-            Errors.USER_NOT_IN_BAD_DEBT
-        );
-    }
 }
